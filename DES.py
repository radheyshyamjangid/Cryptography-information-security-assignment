#!/usr/bin/python3
import random
import time

def pc1(ks):
    k = []
    for i in ks:
        k.append(i)
    kplus = [
        k[56], k[48], k[40], k[32], k[24], k[16], k[8],
        k[0], k[57], k[49], k[41], k[33], k[25], k[17],
        k[9], k[1], k[58], k[50], k[42], k[34], k[26],
        k[18], k[10], k[2], k[59], k[51], k[43], k[35],
        k[62], k[54], k[46], k[38], k[30], k[22], k[14],
        k[6], k[61], k[53], k[45], k[37], k[29], k[21],
        k[13], k[5], k[60], k[52], k[44], k[36], k[28],
        k[20], k[12], k[4], k[27], k[19], k[11], k[3]
    ]
    return [''.join(kplus[:28]), ''.join(kplus[28:])]

def generateShifts(c0, d0):
    subC = {'c0': c0}
    subD = {'d0': d0}
    shifts = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]
    for n, i in enumerate(shifts):
        subC['c%d' % (n+1)] = subC['c%d' % n][shifts[n]:] + subC['c%d' % n][:shifts[n]]
        subD['d%d' % (n+1)] = subD['d%d' % n][shifts[n]:] + subD['d%d' % n][:shifts[n]]
    return [subC, subD]

def pc2(subC, subD):
    k = {}
    for i in range(1, 17):
        s = subC['c%d' % i] + subD['d%d' % i]
        k['k%d' % i] = ''.join([
            s[13], s[16], s[10], s[23], s[0],  s[4],
            s[2],  s[27], s[14], s[5],  s[20], s[9],
            s[22], s[18], s[11], s[3],  s[25], s[7],
            s[15], s[6],  s[26], s[19], s[12], s[1],
            s[40], s[51], s[30], s[36], s[46], s[54],
            s[29], s[39], s[50], s[44], s[32], s[47],
            s[43], s[48], s[38], s[55], s[33], s[52],
            s[45], s[41], s[49], s[35], s[28], s[31]
        ])
    return k

def ip(m):
    return ''.join([
        m[57], m[49], m[41], m[33], m[25], m[17], m[9], m[1],
        m[59], m[51], m[43], m[35], m[27], m[19], m[11], m[3],
        m[61], m[53], m[45], m[37], m[29], m[21], m[13], m[5],
        m[63], m[55], m[47], m[39], m[31], m[23], m[15], m[7],
        m[56], m[48], m[40], m[32], m[24], m[16], m[8], m[0],
        m[58], m[50], m[42], m[34], m[26], m[18], m[10], m[2],
        m[60], m[52], m[44], m[36], m[28], m[20], m[12], m[4],
        m[62], m[54], m[46], m[38], m[30], m[22], m[14], m[6]
    ])

def strxor(s1, s2):
    res = '{:b}'.format(int(s1, 2)^int(s2, 2))
    if len(res) < len(s1):
        return ((len(s1) - len(res)) * '0' + res)
    return res

def expand(s):
    assert(len(s) == 32)
    r = ''.join([
        s[31], s[0], s[1], s[2], s[3], s[4],
        s[3], s[4], s[5], s[6], s[7], s[8],
        s[7], s[8], s[9], s[10], s[11], s[12],
        s[11], s[12], s[13], s[14], s[15], s[16],
        s[15], s[16], s[17], s[18], s[19], s[20],
        s[19], s[20], s[21], s[22], s[23], s[24],
        s[23], s[24], s[25], s[26], s[27], s[28],
        s[27], s[28], s[29], s[30], s[31], s[0]
    ])
    assert(len(r) == 48)
    return r

def sbox(xorr):
    assert(len(xorr) == 48)
    boxes =[
        [ # S1
            [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],
            [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],
            [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],
            [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13]
        ],
        [ # S2
            [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10],
            [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5],
            [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15],
            [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9]
        ],
        [ # S3
            [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8],
            [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1],
            [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7],
            [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12]
        ],
        [ # S4
            [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15],
            [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9],
            [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4],
            [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14]
        ],
        [ # S5
            [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9],
            [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6],
            [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14],
            [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3]
        ],
        [ # S6
            [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11],
            [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8],
            [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6],
            [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13]
        ],
        [ # S7
            [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1],
            [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6],
            [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2],
            [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12]
        ],
        [ # S8
            [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7],
            [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2],
            [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8],
            [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]
        ]
    ]
    inputs = [
        xorr[:6], xorr[6:12], xorr[12:18], xorr[18:24],
        xorr[24:30], xorr[30:36], xorr[36:42], xorr[42:48]
    ]
    results = []
    for i, n in enumerate(inputs):
        results.append(
            '{:04b}'.format(
                boxes[i][int(n[0]+n[5], 2)][int(n[1:5], 2)]
            )
        )
    resultStr = ''.join(results)
    assert(len(resultStr) == 32)
    return resultStr

def p(s):
    return ''.join([
        s[5], s[6], s[19], s[20], s[28], s[11], s[27], s[16],
        s[0], s[14], s[22], s[25], s[4], s[17], s[30], s[9],
        s[1], s[7], s[23], s[13], s[31], s[26], s[2], s[8],
        s[18], s[12], s[29], s[5], s[21], s[10], s[3], s[24]
    ])

def f(r, k):
    expanded = expand(r)
    xored = strxor(expanded, k)
    sboxed = sbox(xored)
    ped = p(sboxed)
    return ped

def ip1(s):
    assert(len(s) == 64)
    return ''.join([
        s[39], s[7], s[47], s[15], s[55], s[23], s[63], s[31],
        s[38], s[6], s[46], s[14], s[54], s[22], s[62], s[30],
        s[37], s[5], s[45], s[13], s[53], s[21], s[61], s[29],
        s[36], s[4], s[44], s[12], s[52], s[20], s[60], s[28],
        s[35], s[3], s[43], s[11], s[51], s[19], s[59], s[27],
        s[34], s[2], s[42], s[10], s[50], s[18], s[58], s[26],
        s[33], s[1], s[41], s[9], s[49], s[17], s[57], s[25],
        s[32], s[0], s[40], s[8], s[49], s[16], s[56], s[24],
    ])

def encrypt(k, m,x):
    [c0, d0] = pc1(k0)
    [subC, subD] = generateShifts(c0, d0)
    x = x
    k = pc2(subC, subD)
    l0 = ip(m)[:32]
    r0 = ip(m)[32:]
    l = {'l0': l0}
    r = {'r0': r0}
    i = 1
    while (i<=x):
        l['l%d'%i] = r['r%d'% (i-1)]
        r['r%d'%i] = strxor(l['l%d' % (i-1)], f(r['r%d' % (i-1)], k['k%d' % i]))
        i += 1
    # return ip1(r['r8'] + l['l8'])
    return ip1(r['r%d' %x] + l['l%d' %x])

def encryptL(k, m,x):
    [c0, d0] = pc1(k0)
    [subC, subD] = generateShifts(c0, d0)
    x = x-16
    k = pc2(subC, subD)
    l0 = ip(m)[:32]
    r0 = ip(m)[32:]
    l = {'l0': l0}
    r = {'r0': r0}
    i = 1
    while (i<=16):
        l['l%d'%i] = r['r%d'% (i-1)]
        r['r%d'%i] = strxor(l['l%d' % (i-1)], f(r['r%d' % (i-1)], k['k%d' % i]))
        i += 1
    while (i<=(x)):
        l['l%d'%i] = r['r%d'% (i-1)]
        r['r%d'%i] = strxor(l['l%d' % (i-1)], f(r['r%d' % (i-1)], k['k%d' % i]))
        i += 1
    # return ip1(r['r8'] + l['l8'])
    return ip1(r['r%d' %x] + l['l%d' %x])


if _name_ == '_main_':
    k0 = '0001001100110100010101110111100110011011101111001101111111110001'
    # m = '0000000100100011010001010110011110001001101010111100110111101111'
    #
    print("time", "round","number", "length")
    av = [0] * 6
    sampleSize = 3000000
    arr = random.sample(range(1,3000001), sampleSize)
    for j in range(len(arr)):
        r = arr[j]
        l = len(bin(r))-2
        m = '0'*(64-l) + bin(r)[2:]
        x = [4,8,12,20,24,16]


        for i in range(len(x)):
            start = time.time()
            if x[i] <= 16:
                encrypt(k0, m,x[i])
            else:
                encryptL(k0,m,x[i])
            end = time.time()
            t = (end-start)* 1000
            av[i]+=t
            print('%.6f'%t,x[i],r,l)

        print()


    print(av)
    newList = [x / sampleSize for x in av]
    print(newList)
